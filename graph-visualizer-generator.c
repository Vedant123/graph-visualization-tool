#include <stdio.h>#include <unistd.h>#include "nauty.h"#include "naututil.h"#include "gtools.h"#define bufSize 1024void generateUndirectedGraphs(char* order);void directGraphs();void formatGraphShow();void formatOrbits();void showGraphCall();void printOrbits();int main(int argc, char *argv[]){    if(argc == 3)   //checks if the appropriate number of command-line arguments are passed in    {        generateUndirectedGraphs(argv[1]);  //calls the geng algorithm to generate all graphs of order argv[1] (the 1st effective argument passed in)                if(argv[2] == 'D')  //if the user wishes to direct the graphs it would simply call the directg function caller defined below        {            directGraphs();        }                formatGraphShow();  //formats the graphs file with Showg                formatOrbits();     //partitions the vertices into their orbital groups    }        return 0;}void generateUndirectedGraphs(char* order){    int geng_argc;    char *geng_argv[4];        geng_argv[0] = "geng";    geng_argv[1] = order;    geng_argv[2] = "gengOutFile.g";    geng_argv[3] = NULL;        geng_argc = 3;        GENG_MAIN(geng_argc, geng_argv);    //runs a geng wrapper function that is defined in the modified Geng.c file}void directGraphs(){    int directg_argc;    char* directg_argv[4];        directg_argv[0] = "directg";    directg_argv[1] = "gengOutFile.g";    directg_argv[2] = "directedOutFile.g";    directg_argv[3] = NULL;        directg_argc = 3;        DIRECTG_MAIN(directg_argc, directg_argv);   //similar to the Geng_Main, the directg.c file is modified to feature a wrapper that can call the process from another C file like this}void formatGraphShow() {    int showg_argc;    char* showg_argv[4];        showg_argv[0] = "showg";    showg_argv[1] = "directedOutFile.g";    showg_argv[2] = "formattedOutFile.g";    showg_argv[3] = NULL;        showg_argc = 3;        SHOWG_MAIN(showg_argc, showg_argv);}void getOrbits(char* graphString){    FILE* file;        if((file = fopen("orbits.g", "a")) != NULL) {            }        //runs the process to partition the orbits through defining a Nauty sparsegraph with the data from the processed graphs        sparsegraph* g = (sparsegraph*)malloc(sizeof(sparsegraph));    SG_INIT((*g));    int n;    stringtosparsegraph(graphString, g, &n);    int nv = g->nv;    int m = (nv + WORDSIZE - 1) / WORDSIZE;    nauty_check(WORDSIZE, m, nv, NAUTYVERSIONID);            DYNALLSTAT(int, lab, lab_n);    DYNALLSTAT(int, ptn, ptn_n);    DYNALLSTAT(int, orbits, orbits_n);    DYNALLOC1(int, lab, lab_n, nv, "malloc");    DYNALLOC1(int, ptn, ptn_n, nv, "malloc");    DYNALLOC1(int, orbits, orbits_n, nv, "malloc");            static DEFAULTOPTIONS_SPARSEGRAPH( options);    options.defaultptn = TRUE;    options.getcanon = TRUE;        options.digraph = TRUE;        statsblk stats;            DYNALLSTAT(setword, workspace, worksize);    DYNALLOC1(setword, workspace, worksize, 50 * m, "malloc");        sparsegraph canon_g;    SG_INIT(canon_g);        nauty((graph*) g, lab, ptn, NULL, orbits, &options, &stats, workspace, 50 * m, m, nv, (graph*) &canon_g);        int *ptr;    for (ptr=orbits; *ptr!=0; ptr++)    {        printf("%d", *ptr);    }        putorbits(file, orbits, 0, 5);}void formatOrbits(){    FILE* fp;    char buf[bufSize];        if ((fp = fopen("directedOutFile.g", "r")) == NULL)    {        perror("fopen source-file");    }        while (fgets(buf, sizeof(buf), fp) != NULL)    {        buf[strlen(buf) - 1] = '\0';                getOrbits(buf);    }        fclose(fp);}